searchState.loadedDescShard("rusty_mos", 0, "Get the array[i] via the raw pointer.\nSpawn the index of the given <code>envid</code>.\nGen a mask from the $h-bit (MSB) to $l-bit (LSB) with 1.\nGet the virtual address (in <strong>kernel segment</strong>) from the …\nGet the physical address of the virtual address in <strong>kernel </strong>…\nGet the <strong>Page Directory Offset</strong> from the virtual address\nGet the Page Number from the physical address\nGet the address(or the frame number etc.) from the page …\nGet the <strong>Page Table Offset</strong> from the virtual address\nRound-up to the specified fractor.\nRound-down to the specified fractor.\nGet the page object of the phisical address.\nGet the kernel virtual address of the page object.\nGet the physical address of the page object.\nGet the page number through the page object.\nGet the physical address of the given virtual address. …\nDefine all the status bits for the cp0 reg.\nDefine the Elf32 struct and the basic contants for use.\nDefine the basic structure used in the env module. As well …\nDefine the Error Code in mos.\nDefinitions about the memory / page and conventions. …\nDefinitions of the conversion macros for the page.\nThe syscall number enum definition.\nDefinition of some misc macros about type and offset.\nThe ELF32 file header structure. The members are defined …\nThe program segment header structure. The members are …\nThe type used in the walker of the header.\nMark the segment as readable.\nMark the segment as writable.\nMark the segment as executable.\nMark the segment as loadble and load-needed.\nThe <strong>virtual</strong> address for the entry point.\nThe segment size in <strong>file</strong>.\nThe segment flag.\nWalk all the program header entry, use the function <code>apply</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nBuild the Elf32Ehdr object from the binary.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe segment size in <strong>memory</strong>.\nThe segment offset.\nThe segment type.\nThe <strong>virtual</strong> address of the segment.\nThe PCB struct. Compatible with the C-Like memory …\nThe env list used only in the <em>kernel</em> mode. For free list.\nEnv link node.\nThe env status enum. Compatible with the C-Like memory …\nThe env tailq list used only in the <em>kernel</em> mode. For sched …\nThe env is not used (free).\nThe IPC data collected together. Compatible with the …\nThe log of NENV.\nThe count of the envs.\nThe env is blocked.\nThe env is running or to be run.\nThe asid for TLB.\nUsed for the static construction. All members are filled …\nUsed for the static construction. All members are filled …\nUsed for the static construction. All members are filled …\nThe data stored in the link list, with the type <code>T</code>.\nThe target virtual address.\nUsed in Lab 6. ///\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe sender’s env id.\nPointing to the first node of this link list. The list is …\nThe env id.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe IPC data collected.\nPointing the next node. If this is the last node, the …\nThe env’s parent env’s id;\nThe page permission.\nThe page directory address of this env.\nPointing the previous node’s <code>next</code> field. If this is the …\nThe priority of this env.\nMark this env’s receiving status.\nThe running status of this env.\nTrap Frame stored in the PCB.\nThe entry of the tlb mod handler in user space.\nThe value passed directly.\nThe environment does not exist or otherwise cannot be used …\nBad path\nFile already exisits\nThe parameter is invalid\nAttempt to send to env that is not recving\nError Codes Enum only for <strong>the Kernel</strong>\nThe maximum count of opened file exceeded\nNo free space left on disk\nThe environment maximum count exceeded\nRun out of memory\nInvalid syscall number\nFile is not a valid executable\nFile or block not found\nError Codes Enum only for <strong>the User’s File System</strong>\nUnspecified or unknown problem\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKernel memory starts from here\nKSEG1 Segment\nKernel stack end at here (the <code>end</code> in the linking script).\nThe maximum count of all the <strong>asid</strong>\nThe physical page size (in bytes).\nBytes mapped by a page directory entry.\nShifted the <em>Page Table Offset</em> and <em>In-Page Offset</em> out to …\nShifted the <em>In-Page Offset</em> out to get the <strong>Page Table Offset</strong>\nCache Coherency Attributes bit. If set, this entry is …\nDirty bit, but really a write-enable bit. 1 to allow …\nGlobal bit. When this bit in a TLB entry is set, that TLB …\nValid bit. If 0 any address matching this entry will cause …\nReserved for COW (start address).\nThe kernel array <code>ENVS</code> will be mapped here.\nThe high-limits of user’s memory\nThe kernel array <code>PAGES</code> will be mapped here.\nNormal user stack top.\nReserved for temporary usage (start address).\nUser test segment start.\nThe uer’s space higher boundary.\nUser’s page tables are stored here (for a PDMAP size).\nThe exception stack top for the user. See also: UTOP\nThe count of the syscalls. It should be updated manually.\nScan a char from the console\nDestory a env by its id and kill it.\nAllocate a new env and make it child of the current env.\nGet the id of the current env.\nReceive a ipc data or wait.\nTry to send an ipc data to a env.\nAllocate memory and map it.\nMap the virtual address to a specified physical page.\nUnmap the address and the page.\nDo kernel panic.\nPrint a straight string ends with zero into the console.\nPrint a char into the console.\nRead from a dev.\nSet the env status and move it between the lists.\nRegister the user-space TLB mod handler for the specified …\nSet the trapframe to he specified env.\nWrite to a dev.\nGive out the CPU time and re-schedule.\nSyscall identifier. The number is ordered by enum …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCore methods for the env module.\nMachine related implementations.\nDo the schedule job.\nLoad an elf-format binary file in memory. This method will …\nBitmap for the asid allocatoin.\nThe global pgdir.\nThe current env.\nThe envs array used in the <em>kernel</em> space. The element in it …\nThe envs array in <em>kernel</em>, mapped to the UENVS and used by …\nFree env list.\nRunnable env list.\nWrapper to make it aligned to a page.\nRun before the <code>env_run</code> for <strong>tests</strong> only\nAlloc an <code>env</code> and setup its vm and PCB.\nCreate an env and load the icode, set the priority. For …\nDestory an env and free it. Re-schedule will be performed.\nFree an env, and remove all its pages. The TLB will be …\nInit the env environment. Put the envs into the free list, …\nRecover from exception, load the specified <strong>TrapFrame</strong>.\nRun the env. Save the CUR_ENV’s trapframe if <code>CUR_ENV</code> …\nSetup the virtual memory of the new-born env.\nGet the env’s PCB by its id. If <code>checkperm</code> is set, the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLoad the icode for the <code>e</code>.\nActually trigger the reboot of the board. But in QEMU, we …\nPut the character (whose size is 1 byte) into teh serial. …\nGet a character (whose size is 1 byte) from the serial. …\nThe data stored in the link list, with the type <code>T</code>.\nReturns the argument unchanged.\nPointing to the first node of this link list. The list is …\nCalls <code>U::from(self)</code>.\nPointing the next node. If this is the last node, the …\nSafety\nPointing the previous node’s <code>next</code> field. If this is the …\nSchedule the envs. If <code>yield</code>, the current env will be moved …\nSafety\nSafety\nSafety\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nSafety\nCalls <code>U::from(self)</code>.\nLink List implemented with Rust, which is similar to the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe head struct of the LinkList\nThe node struct of the LinkList\nThe LinkList with its <strong>tail</strong> recorded\nUsed for the static construction. All members are filled …\nThe data stored in the link list, with the type <code>T</code>.\nConstructor for the default.\nConstructor for the default.\nJudge whether the list is empty.\nJudge whether this list is empty.\nMake the list useable after the construction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPointing to the first node of this link list. The list is …\nInsert the item into the head of the list.\nInsert a node to the head of the list\nInsert the item into the tail of the list.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an empty TailLinkList object. Not useable yet.\nCreate an empty link list with its head null.\nCreate an empty link list node with its linking-field all …\nPointing the next node. If this is the last node, the …\nGet the head and remove it if the list is not empty.\nGet the first node of this list and removce it\nPointing the previous node’s <code>next</code> field. If this is the …\nRemove a specified node from the list contains this node.\nRemove a specified node from the list contains this node.")